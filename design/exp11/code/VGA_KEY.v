
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module VGA_KEY(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
	assign VGA_SYNC_N=0;
	
	wire clk_key;
	wire clk_twink;
	wire[7:0]data;
	//wire[7:0]lastdata;
	wire[7:0]ascii_val;
	wire[7:0]ascii_val_u;
	
	wire[11:0]r;//row
	wire[11:0]c;//col
	wire[3:0]x;
	wire[3:0]y;
	
	reg[11:0]rom[4097:0];//存储点阵
	reg[11:0]cnt;//显示位置
	reg[11:0]cnt_tmp;
	reg[7:0]ascii[2129:0];//字符的ascii码
	
	reg[7:0]ascii_temp;
	wire [11:0]rom_temp;
	
	wire[9:0]h_addr;
	wire[9:0]v_addr;
	wire [11:0]vga_data;
	
	wire ctrl;
	wire shift;
	wire up;
	wire caps;
	
	reg flag=0;
	
	initial begin
		//ctrl=0;
		//shift=0;
		//up=0;
		//caps=0;
		integer i;
		for(i=0;i<=2129;i=i+1)
			ascii[i]=32;
		cnt=0;
		$readmemh("E:/zjq/digital_circuit/design/exp11/vga_font.txt",rom,0,4097);
	end
//=======================================================
//  Structural coding
//=======================================================
	assign LEDR[0]=ctrl;
	assign LEDR[1]=shift;
	assign LEDR[2]=caps;
	assign LEDR[3]=up;
	
	clkgen #(25000000) my_vgaclk(CLOCK_50,1'b0,1'b1,VGA_CLK);
	clkgen #(15) my_keyclk(CLOCK2_50,1'b0,1'b1,clk_key);
	//clkgen #(2) my_twinkclk(CLOCK3_50,1'b0,1'b1,clk_twink);
	
	vga_ctrl my_vga(
	.pclk(VGA_CLK), //25MHz时钟
	.reset(1'b0), //置位
	.vga_data(vga_data), // 上 层 模 块 提 供 的 VGA颜色数据
	.h_addr(h_addr), // 提 供 给 上 层 模 块 的 当 前 扫 描 像 素 点 坐 标
	.v_addr(v_addr),
	.hsync(VGA_HS), // 行 同 步 和 列 同 步 信 号
	.vsync(VGA_VS),
	.valid(VGA_BLANK_N), //消隐
	.vga_r(VGA_R[7:4]), // RGB
	.vga_g(VGA_G[7:4]),
	.vga_b(VGA_B[7:4])
	);
	
	MyKeyboard(			
	.clk(CLOCK_50),
	.clrn(SW[0]),
	.ps2_clk(PS2_CLK),
	.ps2_data(PS2_DAT),
	.data(data),
	.ascii(ascii_val),
	.ascii_u(ascii_val_u),
	.d_digit_low(HEX0),
	.d_digit_high(HEX1),
	.a_digit_low(HEX2),
	.a_digit_high(HEX3),
	.c_digit_low(HEX4),
	.c_digit_high(HEX5),
	//output reg[15:0] count,
	.ctrl(ctrl),
	.shift(shift),
	.up(up),
	.caps(caps)
	);
	
	always @ (posedge clk_key) begin
		if(flag==1)begin
			if(ascii[cnt]==95)
				ascii[cnt]<=32;
			else
				ascii[cnt]<=95;
		end
	
		if (data!=8'hF0)
		begin
			flag=1;
			if (data==8'h66) //backspace
				begin
					if(cnt%71==0)begin//begin of a row delete last n space
						integer j;
						for(j=cnt-1;(j>=cnt-71)&&(ascii[j]!=32);j=j-1);
						
						ascii[cnt]<=32;//空格
						ascii[cnt+1]<=32;//光标删除
						cnt<=j;
					end
					else begin
						cnt<=cnt-1;
						ascii[cnt]<=32;//空格
						ascii[cnt+1]<=32;//光标删除
						//ascii[cnt+2]<=32;
					end
				end
			else if (data==8'h5A)//enter
				begin
					ascii[cnt]<=32;//空格
					//integer i=cnt;
					cnt<=(cnt/71+1)*71;//行数+1
					//put space into last row
					//for(;i<cnt;i=i+1)
						//ascii[i]<=32;
				end
			else
				begin
					if(ctrl!=1&&caps!=1) begin
						if(up==1)begin
							if(shift==1)begin
								if(data!=8'h12&&data!=8'h59)begin
								ascii[cnt]<=ascii_val_u;
								cnt=cnt+1;
								end
							end
							else begin
								ascii[cnt]<=ascii_val_u;
								cnt=cnt+1;
								end
						end
						else begin
							ascii[cnt]<=ascii_val;
							cnt=cnt+1;
							end
						

					end
				end
		end
	end
	
	/*always @ (posedge clk_twink) begin //0x5f(95)
		if(ascii[cnt+1]==95)
			ascii[cnt+1]<=32;
		else
			ascii[cnt+1]<=95;
	end*/
	
	//计算c,r,x,y 得出字符显示的点阵位置
	assign c=h_addr/9;	
	assign r=v_addr>>4;
	
	assign x=v_addr-(r<<4);
	assign y=h_addr-(c<<3+c);
	
	/*
	assign c=h_addr/9;	
	assign r=v_addr>>4;
	assign x=v_addr%16;
	assign y=h_addr%9;*/

	always @(negedge VGA_CLK)
	begin
		ascii_temp<=ascii[r*71+c];
	end

	assign rom_temp=rom[{ascii_temp,x}];
	assign vga_data=(rom_temp[y]==1)?24'hFFFFFF:24'h000000;

endmodule
