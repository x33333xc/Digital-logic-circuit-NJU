
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module TYPING_GAME(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

assign VGA_SYNC_N=0;
wire clkreset;
assign clkreset = SW[0];
wire reset;
assign reset = SW[1];

//////////寻址结构//////////
wire [9:0] mem_ascii [71:0];//某列的ascii码
wire [9:0] mem_row[71:0];//某列的行地址
wire [3:0] mem_v[71:0];//速度
wire [3:0] mem_alv[71:0];//积累量 满v则下移一个像素点
wire mem_valid[71:0];//是否显示位



//=======================================================
//  Structural coding
//=======================================================
//////////键码转换为ascii码//////////
reg [7:0] key2ascii [255:0];
initial begin
	$readmemh("D:/My_design/final/scancode.txt", key2ascii, 0, 255);
end

//////////产生频率//////////

wire clk_1s;
wire clk_60;
clkgen #(25200000) vgaclk(.clkin(CLOCK5_50),.rst(clkreset),.clken(1'b1),
.clkout(vga_clk));

clkgen_vga #(3000) clk_x1(.clkin(vga_clk),.rst(clkreset),.clken(1'b1),
.clkout(clk_60));

clkgen #(30) time_clk(.clkin(CLOCK5_50), .rst(clkreset), .clken(1'b1),
.clkout(clk_1s));

//////随机数生成/////////

wire [7:0] random_ascii;
wire [7:0] random_col;
wire [7:0] random_v;

random_data ascii(clk_60,reset,8'h61,random_ascii);
random_data col(clk_60,reset,8'h30,random_col);
random_data v1(clk_60,reset,8'h35,random_v);


///////////计时///////////
wire [9:0] count_time;
clkgen_1s x2(clk_1s,reset,count_time);

//////////////////vga显示//////////////////
wire [9:0] vga_haddr;
wire [9:0] vga_vaddr;
wire [23:0] vga_data;
wire [9:0]score;
wire [9:0]miss;

vga_ctrl my_vga(.pclk(VGA_CLK), .reset(reset), .vga_data(VGA_DATA), .h_addr(vga_haddr), 
.v_addr(vga_vaddr), .hsync(VGA_HS), .vsync(VGA_VS), .valid(valid), .vga_r(VGA_R), 
.vga_g(VGA_G), .vga_b(VGA_B));
vga_show vga_handle(VGA_CLK,score,miss,vga_haddr,vga_vaddr,mem_ascii,mem_row,mem_valid,VGA_DATA);

///////////handle////////////////
integer i,j,k;
reg [5:0]count_60;
reg [7:0]count4;
reg flag_handle;
wire [15:0] keydata;
ps2_keyboard my_ps(.clk(CLOCK_50),.clrn(reset),.ps2_clk(PS2_CLK),.ps2_data(PS2_DAT),.data(keydata));

always @( negedge clk_60)begin
 if (reset) 
	begin
		count_60=0;
		count4=0;
		for (i=0;i<71;i=i+1)
			begin
				mem_valid[i]=0;
				mem_ascii[i]=0;
				mem_v[i]=0;
				mem_row[i]=0;
				mem_alv[i]=0;
				flag_handle=0;
				score=0;
				miss=0;
			end
	end
		else
			begin
				if (count_60==20)
					begin
						count_60=0;
						if (keydata[7:0]==8'hff||keydata[7:0]==8'hf0)
							flag_handle=0;
						for (j=5;j<68;j=j+1)
						begin
							if (mem_valid[j])
								begin
									if (mem_ascii[j]==key2ascii[keydata[7:0]]&&flag_handle==0)//消除字符
										begin
											mem_valid[i]=0;
											mem_ascii[i]=0;
											mem_v[i]=0;
											mem_row[i]=0;
											mem_alv[i]=0;
											score=score+1;//分数加1
											flag_handle=1;
										end
									else begin
										if (mem_row[j]<479) //字符未下落最下面
											begin
												if (mem_alv[j]==mem_v[j])//达到速度，向下移动1个像素点
													begin
														mem_row[j]=mem_row[j]+1;
														mem_alv[j]=0;
													end
													else begin//未达到速度，alv+1，继续积累
														mem_alv[j]=mem_alv[j]+1;
														end
											end
										else begin//字符下落到最下面
												mem_valid[i]=0;
												mem_ascii[i]=0;
												mem_v[i]=0;
												mem_row[i]=0;
												mem_alv[i]=0;
												miss=miss+1;//miss数+1
												end
											end
								end
							if (count4==200)//在随机列生成随机速度下落的字符
								begin
									if (mem_valid[5+random_col%63]==0)
									begin
										mem_valid[5+random_col%63]=1;
										mem_ascii[5+random_col%63]=8'h61+random_ascii%26;
										mem_row[5+random_col%63]=0;
										mem_v[5+random_col%63]=random_v%8;
										mem_alv[5+random_col%63]=0;
									end
								end
						end
					end
					else begin
						count_60=count_60+1;
						count4=count4+1;
							end
				end
			end
endmodule
